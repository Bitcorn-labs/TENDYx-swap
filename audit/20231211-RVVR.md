# Sneed SNS Dapp

## Security Assessment

December 11th, 2023

Prepared By:
RIVVIR Tech, LLC, Austin Fatheree

### About RIVVIR Tech, LLC

RIVVIR Tech LLC is a Texas based company that provides technology consulting and engineering services.  Among other services, we perform security audits of MOTOKO based canisters and have an extensive history of building MOTOKO based canisters, participating on both sides of the security audit table, and have participated in ICRC Working Groups.  For information regarding our services, please reach out to austin at rivvir.com.

### Disclosure:

This security assessment was conducted within a specified timeframe and depended substantially on data furnished by the client, along with its affiliates and partners. Consequently, it's important to acknowledge that the insights presented in this report do not represent an exhaustive enumeration of all potential security vulnerabilities or anomalies within the evaluated system or codebase. This report highlights key findings as per the information available and the scope of the assessment during the conducted period. We make no warranties or guarantees about the efficacy or security of the audited contracts and these findings are provided as informational content only.  Clients must rely on their own judgment, implementation, and must make their own warranties and guarantees of their published code.

© 2023 by RIVVIR Tech, LLC

All rights reserved. RIVVIR Tech hereby asserts its right to be identified as the creator of this report in the United States, United Kingdom, EU, and Globally.

This report is considered by RIVVIR Tech to be business confidential information; it is licensed to the SNEED DAO for informational purposes. Material within this report may not be reproduced or distributed in part or in whole without the express written permission of RIVVIR Tech LLC.


## Executive Summary

### Engagement Overview

SNEED DAO engaged RIVVIR Tech LLC to review its SNS Dapp Canister.  From December 8th to 11th Austin Fatheree reviewed the contract, made suggestions, investigated the contract and produced this report.

### Project Scope

Our efforts were focused on identifying uneeded complexity, security issues, poor code quality, potential exploits, and other issues involved in the backend canister controlled by the SNEED DAO that is in charge of swapping OLD Sneed tokens for NEW Sneed tokens.

### Summary of Findings

The audit uncovered significant concerns that we feel need to be addressed and/or publicly justified by the team before moving forward with the deployment of the SNEED Swap canister contract. These concerns are addressable and most high severity issues have to do with potential DoS or Cycle Drain attacks.  From our review, it appears the core logic of the canister is sound but we have concerns that the complex logic is under-tested and overly complex for the task at hand.  Particularly, the use of multi-canister calls during conversion and pooling user funds in a single fund should be addressed. A canister that uses those methods can be secure and there may be adequate justifications as to why the canister should use those methods, but we feel that they should be specifically addressed as they seem to be antipatterns that one would want to avoid.

Exposure Analysis

| Severity     | Count |
|--------------|-------|
|High          |      6|
|Medium        |      8|
|Low           |      6|
|Informational |      2|

Category Breakdown

| Severity             | Count |
|----------------------|-------|
| Type Checking        |      1| 
| Session Management   |      3| 
| Error Reporting      |      3|
| Data Validation      |      2| 
| Memory Safety        |      2| 
| Denial of Service    |      2| 
| Complexity Management|      3| 
| Data Handling        |      2| 
| Auditing and Logging |      1|
| Configuration        |      1|
| Testing              |      2|

#### Notable Findings

High Severity findings are listed below:

- RVVR-SNEED-2 - Parallel Burns are possible leading to a loss of OLD Sneed
- RVVR-SNEED-5 - Hard coded limits on indexer results may lead to an attacker trying to generate many small, transactions to manipulate balance totals.
- RVVR-SNEED-8 - Non validation of valid accounts can lead to a cycle drain attack making use of intercanister calls.
- RVVR-SNEED-9 - User funds are held in a common account violating the separation of concerns pattern and leading to increased exploit repercussions.
- RVVR-SNEED-20 - No Integration tests are included.
- RVVR-SNEED-21 - No Unit tests are included.




## Project Goals

Our goals in this project is to make sure that the SNEED Swap canister does what it is intended to do. We want to:

- check motoko coding conventions and best practices
- address intercanister workflows
- identify exploits that would allow the capture of undue New or Old Sneed.
- identify potential cycle drain and DoS attacks.
- make sure upgrades work appropriately

## Project Targets

This Draft was performed against the commit eded97ffaf119decb5a27922e3059ce45eb38d3d at https://github.com/icsneed/sneed_sns_dapp

We audited the backend motoko files.  An audit of the web application was not done.


## Code Maturity

| Category                               | Summary| Result           |
|----------------------------------------|------------------------------------------------|------------------|
| Arithmetic                             | The code handles different token decimal representations and converts between them (from 12 to 8 decimals). It uses arbitrary precision Nats for calculations to avoid overflow issues and checks for underflows as well during token conversions. Careful handling of fee inclusion/exclusion in calculations also demonstrates due consideration of arithmetic concerns.| Strong           |
| Auditing and Logging                               | The contact includes no logging functionality or way to determine how the contract is being used.  Even tracking of converted amounts would need to be derived from two different transaction logs.  There is no way to determine if errors are being encountered by users.| Weak         |
| Authentication / Access Controls       | The contract has some controls to ensure only authorized principals can call certain functions (`assert Principal.isController(caller)`). Functions that potentially modify the state (like token burns and settings updates) are restricted to controllers. There is no user-level authenticity check, but given the dApp's described usage nature, this seems to be by design and not an oversight. However, the lack of critical user-level access control could raise concerns in certain contexts, although it’s claimed not to be a risk by the documentation comments.| Moderate         |
| Complexity Management                 | The code's complexity is managed by splitting functionalities into well-defined private functions (e.g., `IndexOldBalance`, `IndexNewBalance`) and keeping the main logic in public functions clear. The separation of concerns suggests the developers have considered complexity management, which is reinforced by detailed comments.| Strong           |
| Cryptography and Key Management        | The contract doesn’t explicitly handle keys or cryptographic operations outside of the IC’s built-in Principal management since the dApp’s security seems to depend on the Internet Computer's model. There is no custom cryptography or key management, which is appropriate given the platform's capabilities.| Strong           |
| Data Handling                          | The code manages data handling through the use of Motoko's data structures like Maps and Arrays. It also uses stable variables to persist data across upgrades, with system functions for `preupgrade` and `postupgrade` managing data transformation when necessary. The use of types to enforce data structures and explicit error handling for potential data-related issues (like underflows) show attention to data handling. Some memory and compute heavy data structures like the base HashMap should be swapped out for more efficient structures like https://github.com/ZhenyaUsenko/motoko-hash-map             | Moderate           |
| Documentation                          | The smart contract is well documented through comments, explaining its purpose, workings, and specific functionality. It also includes a detailed LEGEND for variable naming conventions to clarify the handling of tokens with different decimals. Such extensive documentation is helpful for both developers and auditors to understand the code's logic and intent.| Strong           |
| Maintenance                            | The use of the `stable` keyword for critical variables indicates the contract is designed to be upgradable without data loss. The presence of `preupgrade` and `postupgrade` hooks likewise demonstrates foresight into the maintenance and lifecycle of the contract. However, the actual process of upgrade is not demonstrated within this code snippet. Comments suggest areas where future updates are expected (e.g., TODO comments on token IDs), indicating ongoing maintenance considerations.| Moderate         |
| Memory Safety and Error Handling       | The Motoko programming language provides memory safety by design, and the code makes use of pattern matching to precisely handle errors (`#Ok`, `#Err`), which provides rigorous error handling. There are also assertions and verifications for transactions, indexed balances, etc., to ensure a consistent state and error propagation in case of anomalies. Some intercanister calls are not wrapped in try/catch logic and may cause unexpected behavior if the network or involved canisters misbehave| Moderate           |
| Testing and Verification               | The code itself does not contain any tests, and there is no mention of testing practices or verification other than comments suggesting caution in specific areas. Testing is crucial for smart contracts given their immutable and financial nature once deployed. Without explicit tests or verification methods, we must classify this as weak even though the code structure suggests it could be written with testing in mind (use of clear, functional elements). Nonetheless, without evidence of testing, such as unit tests or functional tests, it is impossible to gauge the contract's reliability fully.                                                                                                                                  | Weak             |

It should be noted that even with strong results in various categories, a significant factor for smart contract reliability and security is thorough testing and verification, which the given code snippet did not demonstrate. Moreover, while the code shows strengths in several areas, there may be additional risks or concerns that are not apparent without full testing results, auditing records, or operational context.


## Summary of findings


### Title: Type Comparison Warnings

Finding ID: RVVR-SNEED-1

Severity: Medium

Difficulty: Low

Type: Type Checking

Target: `if (tx.index == old_latest_send_txid) { old_latest_send_found := true; };`

#### Description:

The smart contract has a type comparison warning when trying to determine if a transaction index matches the most recent OLD token transfer from the dApp to the account for both the `new_latest_send_txid` and `old_latest_send_txid`. The code currently checks if `transaction.id` or `tx.index` matches the transaction IDs in question without using an `opt` modifier. This fails to account for the fact that `new_latest_send_txid` and `old_latest_send_txid` are optional fields (`?Nat`) and directly comparing them to `Nat` fields will technically work, but is considered poor code quality.

#### Exploit Scenario:

Future updates to the contract may make type assumptions and make a miscalculation based on the wrong type.

#### Recommendations:

Update the code to handle the optional types properly by prefixing `new_latest_send_txid` and `old_latest_send_txid` with an `?` modifier or by using appropriate pattern matching to compare values correctly. The comparison should be structured to handle optional values robustly, for example:

```motoko
if (?tx.index == old_latest_send_txid) { old_latest_send_found := true; };

// ...in another part of the contract, handle the case where old_latest_send_txid is null:

if (old_latest_send_txid != null and ?transaction.id == old_latest_send_txid) { old_latest_send_found := true; };
```

### Title: Parallel Burn
Finding ID: RVVR-SNEED-2

Severity: High

Difficulty: Medium

Type: Parallel Burn

Target: `burn_old_tokens``

#### Description:
The `burn_old_tokens` function in the smart contract handles the burning of old tokens (OLD SNEED) from the dApp. The function is meant to be called by the dApp controllers only, and it is critical to ensure that unconverted old tokens are not accidentally burned, as this would leave users unable to refund their old token balances. However, the current implementation poses a risk because there is no mechanism in place to prevent multiple burn transactions from occurring simultaneously if multiple DAO proposals pass at the same time (often referred to as 'fat fingering'). This parallel burn scenario could potentially result in burning more tokens than intended, impacting the financial integrity of the token exchange process.

#### Exploit Scenario
Suppose a controller erroneously submits two DAO proposals to burn a certain quantity of OLD SNEED, and both proposals pass due to a timing coincidence or lack of attention from the DAO members. In the current contract setup, both `burn_old_tokens` calls can execute nearly concurrently. Since there is no flag within `burn_old_tokens` to prevent a second instance from running, both instances could initiate a burn for the same amount, resulting in a double burn effect and the unintended loss of tokens.

#### Recommendations
To mitigate this issue, introduce a locking mechanism within the `burn_old_tokens` function. You can use a boolean flag, such as `can_burn`, that is initially set to `true`. When the `burn_old_tokens` function commences, set `can_burn` to `false`. The flag should only be reset to `true` once the burn process completes or fails. Furthermore, to ensure atomicity and prevent race conditions, checks and state changes to the `can_burn` flag should be made within the same critical section.

This approach ensures that only one burn process can be executed at any given time, thus preventing accidental double burns. Additionally, leveraging the existing cooldown system could supplement this protection, combining a flag with a cooldown period for extra safety and ensuring that proposed burns are spaced out appropriately.

Here is a recommended pseudocode snippet that you could integrate into the existing contract:

```motoko
// Declare a stable variable to store the burn state
stable var is_burning : Bool = false;

public shared ({ caller }) func burn_old_tokens(amount : T.Balance) : async T.BurnOldTokensResult {
  // Ensure the dApp has been activated
  if (IsInactive()) { return #Err(#NotActive); };
  
  // Ensure only controllers can call this function
  assert Principal.isController(caller);
  
  // Prevent parallel burns by checking if a burn is already in progress
  if (is_burning) {
    return #Err(#BurnInProgress);
  }
  
  // Lock the burn process to prevent concurrent burns
  is_burning := true;
  
  // Attempt to burn old tokens
  let burn_result = await AttemptBurnOldTokens(amount);
  
  // Unlock the burn process after completion or failure
  is_burning := false;
  
  // Return the result of the burn attempt
  return burn_result;
};
``` 

Implementing this change will help protect the integrity of the dApp's token management system and prevent financial complications from unintended token burns. Due diligence should be taken to test the updated smart contract thoroughly to ensure that the locking mechanism functions as intended and does not introduce new issues or side effects.

### Title: await Pattern Misuse Leading to State Commit Vulnerabilities
Finding ID: RVVR-SNEED-3

Severity: Medium

Difficulty: Medium

Type: Session Management

Target: Lines where "await" is used, e.g., lines with `await IndexAccount(...);`, `await ConvertOldTokens(...)`, and `await RefundOldTokens(...)`.

#### Description:

The smart contract uses the `await` pattern incorrectly when calling functions on the same canister. This misuse is noted in the public functions `get_account`, `convert_account`, and `refund_account`, as well as in the private functions `ConvertOldTokens` and `RefundOldTokens`. Utilizing `await` in this manner leads to additional commit points in the state of the contract, which opens up opportunities for attackers to re-order transactions advantageously. These additional commit points can be leveraged by an attacker with in-depth system knowledge to manipulate the system state, leading to potential vulnerabilities such as state corruption, re-entrancy, or front-running attacks. Reducing unnecessary state commits is essential for contract reliability and security.

#### Exploit Scenario:

Alice is aware that the smart contract for Sneed Converter creates unnecessary state commit points when calling internal functions with `await`. She crafts transactions that take advantage of this by issuing calls that she expects will lead to these commit points. By predicting the timing of her transactions and potentially colluding with a malicious node operator.

#### Recommendations:

Use `async*/await*` calls rather than `async/await` for functions within the same canister to prevent unnecessary round-trips and state commits.

### Title: Absence of try/catch handling for asynchronous canister awaits
Finding ID: RVVR-SNEED-4

Severity: Medium

Difficulty: Low

Type: Error Reporting

Target: Throughout the smart contract, particularly in functions like `ConvertOldTokens` and `RefundOldTokens`

#### Description:
The current implementation of the smart contract does not have any try/catch handling mechanism around the asynchronous operations. When performing awaited calls (such as interacting with token canisters, indexers, and other external calls), the contract assumes that these calls will be successful, or if they fail, they will do so with standard error returns. However, unexpected errors can occur, and these are not currently being handled gracefully.

An issue may arise when a user attempts a conversion or refund after a failed canister call. If the failure is the result of an exception thrown from an awaited function and not caught within the smart contract, the user may be mistakenly put on a cooldown due to the state being committed with no rollback in place. As a result, users may be blocked from reattempting conversions or refunds and would have to wait out the cooldown period, despite their operation not being successful. This experience might be confusing and frustrating for users.

#### Exploit Scenario:
Alice tries to convert her OLD tokens to NEW tokens through the `convert_account` function. An awaited call to an indexer canister fails, and the smart contract code throws an exception that is not caught. As a result, the contract puts Alice's account on cooldown because the cooldown state was set before the canister call. Alice cannot reattempt conversion until the cooldown expires, even though no actual conversion took place.

#### Recommendations:
- Implement try/catch error handling logic around awaited calls to external canisters.
- Rollback the cooldown state after any external calls have error.
- Consider providing a more detailed error message that includes the specific action users can take when encountering an error.n.
- Test error handling pathways thoroughly, including handling of unexpected exceptions from awaited calls.

To implement this, the following code blocks should be updated with proper error handling:
- In `ConvertOldTokens` and `RefundOldTokens`, use try/catch when calling other canister methods and when performing state changes.
- In `IndexAccount`, consider handling errors in both the calls to the new token indexer and the old token indexer as these are critical operations for the contract state.
- Review any other external calls to other canisters or services to ensure the absence of unhandled exceptions, and if required, apply similar error handling measures.


### Title: 100000 Results - Max Results Attack
Finding ID: RVVR-SNEED-5

Severity: High

Difficulty: Medium

Type: Data Validation

Target: line 596 - `max_results = 100000;`

#### Description:

The IndexAccount private function uses a max_results limit of 100,000 when fetching transaction results from the OLD and NEW token indexers. If an attacker manages to execute a significant number of transactions, specifically over 100,000, they could potentially manipulate the balance calculations within the dApp. This is because transactions beyond this limit would not be considered in the balance computation, leading to inaccurate reflections of account balances. An attacker could exploit this to convert more NEW tokens than they are entitled to or to reclaim more OLD tokens than they should be able to.

#### Exploit Scenario

An attacker could potentially flood the system with more than 100,000 small transactions to either the OLD or NEW token indexer. Once they exceed this threshold, their subsequent transactions would not be included in the balance calculations performed by the `IndexAccount` function. For example, if the attacker performs additional transactions after the 100,001st transaction, these transactions may go undetected. This could lead to a scenario where the attacker can convert more OLD tokens to NEW than they should be able to, or vice versa, they may also be able to claim a refund for more OLD tokens than warranted.

#### Recommendations

1. Adjust the logic within the `IndexAccount` function to handle more than 100,000 transactions. This could involve processing the transactions over multiple rounds if the limit is hit and aggregating the results, ensuring all transactions are accounted for before computing the balance.
2. Validate the transaction count during each session and reject requests from any account that has an excessive number of transactions unless it has a legitimate reason for such high activity.
3. In cases where support for more than 100,000 transactions is necessary, the contract should iteratively fetch transactions using the indexer. After each batch, it should verify if the count has reached the limit. If it has, the contract should continue fetching the next batch until it gets a response batch with less than the max number of allowable items, indicating all transactions have been retrieved.

### Title: Async Indexer Checking
Finding ID: RVVR-SNEED-6

Severity: Medium

Difficulty: High

Type: Session Management

Target: Lines related to balance and transaction indexing, conversion, and cooldown logic (see multiple lines scattered across the provided code)

#### Description:

The smart contract for the Sneed "Converter" dApp contains a potential issue in tracking and converting balances from OLD tokens to NEW tokens and vice versa. The transactions between users and the canisters store an index, and the contract relies on the ledger property that transactions can only increase. This means that although there might be a time lag in updating indices, any difference should eventually balance out over time.

However, there's a concern that while the state of the canister won't change by having different convert or refund requests within the cooldown period, ongoing transactions out of or into the users' account during index processing may not be captured promptly or accurately, leading to incorrect balance calculations.

#### Exploit Scenario

A user initiates a conversion or refund request. While processing, other transactions are posted to their accounts with the OLD or NEW ledgers. If these transactions aren't captured in the current indexing batch, the user might receive more or fewer tokens than they should. Additionally, if a canister reverts to earlier persisted states but doesn't check against a potentially updated global ledger, it might act on outdated balance information.

#### Recommendations

To address this issue, we recommend the following actions:

1. Extend and enforce a cooldown time to reduce the risk of state inconsistencies due to concurrent transaction processing. The smart contract already implements a cooldown mechanism, but ensuring a minimum of 5 minutes would improve robustness.
   
2. Review and improve the integration tests to cover scenarios involving concurrent and out-of-order transactions to ensure that the system handles them gracefully. This should include tests where indexing and processing delays are artificially inserted to mimic network latency and indexing backlog scenarios.
   
3. Introduce alerts and circuit breakers that pause sensitive contract operations when the indexers detect anomalies or fail to update within a given timeframe, preventing potential losses or exploitation.

### Title: Cooldown State Not Persisted Across Upgrades
Finding ID: RVVR-SNEED-7

Severity: Low

Difficulty: Undetermined

Type: Memory Safety

Target: (pre/postupgrade)

#### Description:
The current implementation of the smart contract uses in-memory state maps to hold the cooldown state for accounts that interact with the `convert_account` and `refund_account` functions. These maps are declared with `let` statements, indicating that they are not stable across upgrades:

```motoko
let cooldowns = Map.HashMap<Principal, Time.Time>(32, Principal.equal, Principal.hash);
```

When the smart contract is upgraded, any cooldown state present in the `cooldowns` map is lost because the smart contract's memory is wiped clean. As a result, accounts that were on cooldown immediately before the upgrade would have their cooldowns reset, allowing them to potentially take actions that should be restricted by the cooldown period.

#### Exploit Scenario:
Bob interacts with the Sneed Converter dApp and triggers a cooldown period by initiating a token conversion. An upgrade to the dApp is performed while Bob's cooldown is active. After the upgrade, the cooldown state is not preserved, so Bob is able to immediately initiate another conversion without waiting for the original cooldown period to elapse, potentially introducing fairness issues or unexpected behavior.

#### Recommendations:

To address this issue, the cooldown state should be preserved across contract upgrades. This can be achieved by utilizing stable variables to store the cooldown information.

### Title: Cycle Drain Attack via Intercanister Calls

Finding ID: RVVR-SNEED-8

Severity: High

Difficulty: Low

Type: Denial of Service

Target: Public API (convert_account, refund_account, get_account)

#### Description:

The SNEED "Converter" dApp allows for the conversion and refund of OLD tokens to NEW tokens through calls to external indexer services. Each call to convert or refund OLD tokens to the dApp initiates two cross-canister calls to indexing servers, which may be cross subnet and thus relatively expensive in terms of cycle consumption. The intercanister calls cost roughly 260,000 cycles before factoring in the transmission size. In the scenario with very active accounts, especially those engineered to be large as part of an attack, the transmission size can become significant. The current implementation lacks a proper filtering mechanism to protect against attack vectors exploiting these intercanister calls. An attacker could exploit this by making repetitive conversion or refund requests with random principal requests, leading the canister to make calls that ultimately result in no action taken, draining the canister cycles and potentially rendering the service unavailable.

#### Exploit Scenario

An attacker could create one or multiple accounts with artificially inflated sizes intended for a cycle drain attack. By repeatedly initiating calls to the `convert_account` or `refund_account` methods with these accounts, each requiring two intercanister calls to indexing servers (old_indexer_canister and new_indexer_canister), the attacker can deplete the cycles in the SNEED "Converter" dApp's canister. Successful execution of this exploit could ultimately drain all cycles from the canister, causing a denial of service and preventing legitimate conversions or refunds from being processed. The cost is likely on the order of $1/million calls, so, given the limitations of ingress to the IC and intercanister communication, the attack may take some time, but could ultimately have a material impact.

#### Recommendations

To mitigate this vulnerability, the canister creator should carefully consider the potential for attacks and the trade-off between on-demand conversion functionality and security against cycle drain attacks.

1. Cache Transactions via a canister Timer and store in a Map<Account, Vec<Transaction>> for syncrynous calculations.
  
  - Pre-fetch and cache index data: Instead of making on-demand intercanister calls, schedule regular fetches of transaction data from the indexing servers. Maintain a local transaction index that would be updated periodically and referenced during conversions or refunds, minimizing the need for real-time intercanister communication.

-  Implement transaction checkpoints: Allow users to convert or refund only up to the latest checkpoint, which is updated at regular intervals. This process significantly reduces the need for intercanister calls.

- Expose a limited catch-up function: If real-time updates are necessary for business continuity, consider exposing a function that allows for periodic catch-up calls. This function could be heavily rate-limited (e.g., once per minute) to control cycle consumption.

- Upgrade frontend logic: Adjust the dApp's frontend to only trigger catch-up calls only when necessary, such as when a user sends tokens to the dApp canister, and implement logic to check the latest tip of each index before making such calls.

2. Implement rate limiting: Restrict the frequency of convert and refund requests globally(a global cooldown).

3. Require authentication: Introduce an authentication or verification measure for users, such as signing transactions, to ensure only legitimate users can perform conversions or refunds.

7. Adjust canister economics: Consider implementing an automated mechanism for cycle replenishment, or passing on the cost by charging a fee for conversion and refund operations that can be directed at replenishing cycles.

These recommendations aim to balance the need for on-demand functionality against the risk of a denial-of-service attack via cycle drainage. It is essential to continuously monitor and assess the threat landscape to adapt the mitigation strategy accordingly.

### Title: Inadequate Account Management Through Single-Account Risk
Finding ID: RVVR-SNEED-9

Severity: High

Difficulty: Low

Type: Complexity Management

Target: Referencing multiple points, primarily conversion function logic.

#### Description:

The current canister design assumes all users are sending their OLD SNEED to the same account, specifically the default account of the canister. This approach leads to all user funds being intermingled within a single account, escalating the danger associated with any potential contract bugs and their subsequent impact. The risk is amplified because should an exploit or bug surface, it would potentially compromise the entirety of the mixed user funds instead of isolating such an error to an individual user's subaccount.

#### Exploit Scenario

A malicious actor or an unintentional bug could trigger an incorrect balance computation or conversion, affecting all users' funds due to the use of a shared default account. If, for example, an exploit allows a user to claim more NEW SNEED than they are due, they could drain the collective pool of NEW SNEED allocated for all users converting OLD SNEED. The consequences of such a scenario are far more severe without subaccount compartmentalization, leading to a loss of trust and potentially significant financial damage to users.

#### Recommendations

It is highly recommended to implement the subaccount pattern described above, where an individual account is tied to a particular subaccount for token transactions. By doing this, it becomes possible to directly match the exact amount for conversion or withdrawal using simple, vetted ledger canister operations without intricate balance computation logic within the conversion canister.

The resistance to subaccounts due to the login or deposit address request requirement can be mitigated by creating a mechanism for users to receive subaccounts without logging in. The process can be automated and integrated into the user interface, ensuring minimal friction for the end-user.

Additionally, there should be safeguards and monitoring tools to manage and guard against denial of service attacks related to subaccount generation and management, including requiring that any generated subaccounts actually do have a token balane in OLD or NEW Sneed(See internal index suggestion to avoid intercanister calls).

## Title: get_account, convert_account, refund_account - Text Input
Finding ID: RVVR-SNEED-10

Severity: Medium

Difficulty: Low

Type: Denial of Service

Target: The function signatures of get_account, convert_account, and refund_account respectively

#### Description:
The `get_account`, `convert_account`, and `refund_account` functions accept an `owner` parameter of type `Text` that is later converted to a `Principal` using `Principal.fromText(owner)`. Malicious actors can exploit this by sending a 2MB `Text` value in the call, potentially causing a cycle drain on the canister. Such calls would unnecessarily consume cycles for converting large `Text` input to `Principal`, even if they are bound to fail. 

#### Exploit Scenario
A malicious actor sends a request to `convert_account` with a 2MB string as the `owner` parameter. The smart contract attempts to process this large string to convert it into a `Principal`, resulting in a cycle drain because of the large and likely malformed input.

#### Recommendations
To prevent the cycle drain, it is recommended to change the function signatures for `get_account`, `convert_account`, and `refund_account` to accept a `Principal` type directly for the `owner` parameter instead of `Text`. Additionally, adding an `inspect_message` function would help reject any unusually long `owner` parameters or subaccounts(see https://internetcomputer.org/docs/current/motoko/main/message-inspection). It would also safeguard against unexpectedly large inputs that may lead to denial of service (DoS) attacks.

Furthermore, converting the function to a query, if possible, may alleviate the cycle consumption issue since queries do not charge cycles. Maintaining an internal index or ledger would facilitate this transition.

Note that `inspect_message` only scrutinizes ingress messages and will not filter requests from other canisters. Hence, it is crucial to add logic to each function to check for and limit expensive operations that may arise from malformed data.

Finally, consider implementing additional checks and limits on the size of `Text` input to guarantee that only reasonably sized inputs are processed, thereby preventing abuse and preserving canister cycles.

### Title: Unnecessary Complexity Due to Refunds Mechanism
Finding ID: RVVR-SNEED-11

Severity: Medium

Difficulty: Low

Type: Complexity Management

Target: N/A (General Behavior)

#### Description:
The smart contract under audit, responsible for the conversion of 'OLD SNEED' tokens to 'NEW SNEED' tokens, includes a mechanism for refunds. This refunds feature allows users to send 'OLD SNEED' tokens back to their original account. The existence of this functionality presents unnecessary complexity and increases the potential for financial risks inherent to the contract logic.

The rationale behind the feature's inclusion is unclear, as the primary and sole purpose of this contract seems to be the conversion of old tokens to new ones post the launch of the new Sneed SNS and the introduction of the 'NEW SNEED' token. The refunds feature complicates the logic by maintaining and updating a separate mapping of transactions for refunds, as evidenced by a dedicated `stable_old_latest_sent_txids` variable and a separate indexing logic section. These considerably increase the contract's complexity, making auditing and reasoning about the contract's behavior more difficult.

Given the contract’s intended use case, refunds pose an additional financial risk, as they may lead to scenarios where the contract's logic around conversion and refund might not be appropriately aligned, potentially resulting in incorrect token balances or erroneous transactions. These risks are not just theoretical but could materialize if there are bugs in the implementation, discrepancies in balance calculations, or issues with the synchronization of the old and new indexer canisters.

#### Exploit Scenario
While not an exploit in the traditional sense, the presence of a refunds feature can lead to intricate scenarios where users may unintentionally receive refunds, or the contract's state might not accurately reflect the user's true token balance post-conversion. An example scenario could be users sending 'OLD SNEED' tokens to the dApp, prompting a refund due to a misunderstood condition or an error in the indexing of balances, resulting in an unanticipated distribution of funds.

#### Recommendations
To simplify the contract and reduce potential financial risks, it is recommended to either eliminate the refund functionality or restrict it to a strictly governed process. This governance could involve SNS Governance so that public oversight of refunds is possible. Restricting the refund process can help ensure that the refunds are intentionally executed and reduce the risk of accidental transactions due to bugs or logic errors within the smart contract. If a governed approach to refunds is not practical, then entirely removing the refund feature would be the optimal course of action to streamline the conversion process and minimize potential risks. Additionally, the documentation should be updated to clarify the conditions under which refunds are permitted and the governance mechanisms in place to handle refunds securely.

### Title: Burned Block Pattern Optimization
Finding ID: RVVR-SNEED-12

Severity: Informational

Difficulty: Medium

Type: Complexity Management

Target: N/A 

#### Description:
The current implementation of the Sneed "Converter" dApp, which allows the conversion of OLD tokens to NEW tokens, involves querying the OLD and NEW token indexers for all transactions related to an account before performing a conversion or refund. In this model, the dApp computes the balance for accounts by summing token inflows and subtracting outflows for both OLD and NEW tokens.

A more efficient method could involve utilizing a "burned block pattern." This pattern involves maintaining a list of blocks processed by the dApp—specifically, token transactions that have already been acted upon (converted or refunded) and marking them as processed or "burned." The dApp would reject any attempts to process it further. This method can reduce the overall data processing overhead and potentially simplify the logic within the smart contract.

#### Exploit Scenario:
N/A (the issue is not directly exploitable, but it does imply that inefficiencies could be causing higher costs or slower execution)

#### Recommendations:
Introduce the burned block pattern for managing transactions. This will entail:
- Implementing in-canister Map within the dApp, which stores a list of transaction blocks marked as burned.
- Instead of checking balances, just check for blocks and forward the amounts in blocks one way to the account the tokens were received from.
- Adjusting refund and conversion functions to mark blocks as burned when a transaction is processed.
- Ensuring concurrency control measures are in place to manage state consistency when marking blocks as burned(burn before processing with rollback logic on failure).

### Title: Null Fee in TransferArgs Could Lead to Unhandled Fee Configuration Changes
Finding ID: RVVR-SNEED-13

Severity: Medium

Difficulty: Low

Type: Data Handling

Target: "let transfer_args : T.TransferArgs = { ... fee = null; ... }" (multiple occurrences inside private functions such as `ConvertOldTokens`, `RefundOldTokens`, etc.)

#### Description:

The smart contract code provided contains sections where the `fee` field within `TransferArgs` is explicitly set to `null`. This poses a potential risk if the fee amounts associated with token transactions are dynamically configurable, particularly through governance decisions that might change the fees independently of this smart contract.

A `null` value for the fee assumes that the ledger or token canister will apply a default fee. However, if the default fee changes and the smart contract is not promptly updated to reflect the new required fee, transactions may start failing due to incorrect or insufficient fee amounts.

Given that token contract behaviors might depend on the fee to ensure spam protection, priority order in transaction processing, or additional revenue, relying on a default rather than explicitly specifying the fee could lead to mismatched expectations, failed transactions, and potential financial losses or user dissatisfaction.

#### Exploit Scenario

Suppose the governance body or administrators responsible for setting the default transfer fees within the token canister decide to change the fee from 1_000 (new_fee_d8) to 2_000. This change happens without the smart contract's knowledge since the `fee` parameter is explicitly set to `null`. As a result, all new transactions originating from this contract could fail due to insufficient fee allocation.

#### Recommendations

To avoid possible transaction failures due to misaligned fees, the smart contract should specify fees in the transfer args explicitly, rather than relying on default behavior. By doing so, transactions are ensured to either execute with the correctly supplied fee or fail if the fee becomes incorrect due to external changes, signaling the need for a smart contract update. Here are the recommendations:

1. Replace `fee = null;` within `T.TransferArgs` with `fee = ?new_fee_d8;` or `fee = ?old_fee_d12;` as applicable, to reflect explicitly the desired fee configuration.

2. Include tests and checks within the smart contract upgradability plan to validate that fee parameters are aligned with current token canister configurations post-upgrade.

### Title: Null Memos
Finding ID: RVVR-SNEED-14

Severity: Low

Difficulty: Low

Type: Data Handling

Target: Memo field creation

#### Description:

The smart contract currently does not include memos in the transfer arguments during token transfers. While this omission does not directly affect the core functionality, it may lead to challenges when tracking and auditing transactions across block explorers and financial software that rely on memos to correlate and contextualize transactions. Because of the nature of smart contracts and token exchanges, having a non-null memo included with every transaction can facilitate easier tracking, debugging, and interfacing with third-party tools or services that consume transaction data.

#### Exploit Scenario

N/A

#### Recommendations

To improve the transparency of transactions and simplify the work of auditors and users, it is recommended that the smart contract should be modified to include non-null memo fields within the transfer arguments. Here's how the transfer argument could be modified in each applicable function:

```
  memo = ?sha256.hash(Text.encodeUTF8("OldSneedConversion")); // Memo added to identify transaction as a conversion
```

### Title: Meaningful Error Codes
Finding ID: RVVR-SNEED-15

Severity: Low

Difficulty: Low

Type: Error Reporting

Target: Various - `error_code =0``

#### Description:

The smart contract's error handling uses an `error_code` field with a zero value in several places. The `error_code` field is intended to provide additional context regarding errors, improving the developer's ability to understand and debug issues that may arise. Currently, the field always carries a zero value, which does not provide any context and thereby diminishes its usefulness. If error codes have predefined meanings assigned to them, they should be consistently implemented throughout the smart contract for each unique error type. If no predefined meanings are planned, the field could be removed. Otherwise, it should be used effectively to convey specific error information.

#### Exploit Scenario:

N/A

#### Recommendations:

Modify the smart contract to implement a system of unique error codes corresponding to different error situations. Define a consistent and clear convention for these codes and document their meanings for easy reference. For instance, `error_code` 1 could be an insufficient funds error, while `error_code` 2 could be an invalid principal error, and so on. Following this recommendation will improve clarity and troubleshooting during development and maintenance, and could also provide more informative error messages for end-users. 

Ensure that the meaningful error codes are implemented across all instances where errors are handled within the contract, specifically in the `ConvertOldTokens` and `RefundOldTokens` private functions where currently a generic `error_code` of 0 is utilized.

### Title: Error Conditions from Indexer Checks
Finding ID: RVVR-SNEED-16

Severity: Low

Difficulty: Low

Type: Error Reporting

Target: Indexing functions

#### Description:

The smart contract utilizes indexer checks for understanding the status of OLD and NEW SNEED token transactions between an account and the Sneed Converter dApp. However, conditions such as `indexed_account.old_latest_send_found == false` indicate two separate issues: the possibility that the indexer is stale, or that no relevant transactions were found for the account. These conditions should be disentangled to provide clearer error messaging, which can assist with troubleshooting and enhance the dApp user experience.

#### Exploit Scenario

While not an exploit directly affecting security or funds, the lack of clarity in error messaging can cause issues for end-users and support staff. If the user or an administrator encounters the stale indexer error, they may not know whether to wait for the indexer to update (stale indexer) or to verify the transaction history (no transactions). Distinguishing between a stale indexer and an absence of transactions could save time and reduce confusion in resolving issues.

#### Recommendations

Recommendations include:

1. **Separate Error Messages:** Implement separate error messages in the smart contract for a stale indexer and for no found transactions, respectively. This delineation will require additional logic in the contract code to differentiate between these two cases.

2. **Improve Condition Checks:** Modify the condition statements in the indexing functions, where accounts are indexed, to more precisely identify and categorize the encountered condition, ensuring that accurate feedback is given.

3. **Update Documentation:** Amend the smart contract documentation to clearly explain the possible error messages and the appropriate steps to take in each case, which could alleviate user concerns in the event of an error.

4. **Unit Tests:** Write unit tests encompassing various scenarios where the indexer may be stale or transactions for an account are not found. Testing these situations will help to ensure that the contract reacts correctly and error messages are displayed as intended.

5. **User Interface Handling:** If the dApp has an associated frontend, ensure error messages are plainly displayed and guidance is provided on how to proceed, reducing the need for users to contact support.

### Title: Lack of Logging Mechanism
Finding ID: RVVR-SNEED-17

Severity: Informational

Difficulty: Low

Type: Auditing and Logging

Target: Entire Smart Contract

#### Description:

The Sneed "Converter" dApp currently does not have a logging mechanism in place. Without logging, it is challenging to analyze or debug the system's behavior post hoc, which is crucial for understanding how the application operates over time or diagnosing issues after they have occurred.

#### Exploit Scenario

Alice, the administrator of the Sneed "Converter" dApp, notices unusual patterns in the conversion rates and amounts. Without a logging facility, she finds it difficult to trace the activities that might have led to these patterns. Logging would have provided her with detailed insights into the system's operations and helped identify potential issues or malicious activities.

#### Recommendations

Implement a logging mechanism to track key operations within the smart contract. Consider adopting a solution like CanisterGeek( https://cusyh-iyaaa-aaaah-qcpba-cai.raw.ic0.app/) to provide off-the-shelf logging and monitoring capabilities for the canisters. Integrate logging at critical functions of the contract, such as `convert_account`, `refund_account`, and `burn_old_tokens`, to record successful operations, errors, and transaction details that are essential for audit trails.

Logs should be structured to capture relevant information (e.g., timestamp, principal ID, operation type, result) and should be retained for a reasonable period to facilitate post hoc analysis. Ensure that the logging solution complies with privacy standards and only logs pertinent details. Set up alerting and monitoring around the logs to quickly detect any anomalies or issues requiring immediate attention.

### Title: Improper Use of Integer Type for d12_to_d8 Conversion Variable
Finding ID: RVVR-SNEED-18

Severity: Low

Difficulty: Low

Type: Data Validation

Target: `stable var d12_to_d8 : Int = 10_000; // 12 to 8 decimals`

#### Description:
The contract defines the variable `d12_to_d8` using the `Int` type to represent the conversion factor between tokens with 12 decimals (OLD tokens) and tokens with 8 decimals (NEW tokens). This is potentially confusing as the conversion factor is inherently a positive number, and the use of an integer allows for negative values, which are non-sensical in this context.

Further, the contract utilizes the `Int.abs` method across the codebase to ensure the positivity of certain calculations involving this variable. The reliance on this function introduces an unnecessary layer of complexity and increases the cognitive load for reviewers and auditors who have to verify the correctness of these operations and ensure that negative values are not being unintentionally used or validated.

#### Exploit Scenario
Given that the `d12_to_d8` conversion factor should never be negative, there isn't a direct exploit scenario stemming from the misuse of the `Int` type for this variable. However, the use of `Int.abs` in calculations scattered throughout the code implies that negative values can be introduced, which may lead to incorrect calculations if improperly handled.

#### Recommendations
Switch the type of `d12_to_d8` from `Int` to `Nat` to ensure that the conversion factor between d12 and d8 cannot mistakenly be a negative value. This change should simplify the code by removing the need for the `.abs` calls to validate the conversion factor, thereby reducing the potential for errors and making the code more readable and auditable.

Search for and remove any `.abs` methods that were previously necessary due to the `Int` type being used. Replace these methods with direct variable usage, as `Nat` guarantees non-negative integers.

Additionally, you should audit and test all code paths that were previously using `d12_to_d8` to ensure that they handle the variable's type change from `Int` to `Nat` correctly and that no other parts of the code expect it to be able to handle negative values.

### Title: Inadequate Set-Up of Smart Contract’s Canister ID
Finding ID: RVVR-SNEED-19

Severity: Medium

Difficulty: Low

Type: Configuration

Target: Line where `sneed_converter_dapp` is assigned.

#### Description:
In the provided Motoko smart contract for the Sneed "Converter" dApp, there is a requirement to set the actual canister ID for the `sneed_converter_dapp` to be operative and direct transactions appropriately. Currently, it's assigned a placeholder value `"aaaaa-aa"` which seems to be a stand-in for development purposes. The configuration imperative is placed under a `TODO` directive implying pending completion. Using the `actor class` pattern and referencing `this` implies the need to refer to the deploying canister itself, ensuring the ID used within the contract reflects the dApp's canister. Given that the actor class pattern is utilized, achieving this will provide a robust mechanism for binding to the correct identity of the running canister instance.

#### Exploit Scenario:
Alice deploys the smart contract as it is. Alice updates the canister ID to an inaccurate Principal ID resulting in misrouted transactions since the dApp won't correctly identify itself in interactions. This misidentification could lead to confusion or, more severely, the loss of funds if transactions are sent to an unintended recipient. This issue is even more critical given the context of token conversions within the dApp's functionality.

#### Recommendations:
To resolve this configuration issue, it's recommended to identify the canister ID dynamically at runtime using the introspective features available within Motoko’s `actor class` pattern. This can be achieved by leveraging `Principal.fromActor(this)` within the dApp's instantiation logic, ensuring that the `owner` property of `sneed_converter_dapp` correctly binds to the executing canister ID. It is also advised to remove the placeholder and any associated todos that may lead to the deployment of unconfigured code to production.

To amend the smart contract, the following adjustments should be made where the `sneed_converter_dapp` is defined:

Replace the line containing the `TODO` comment with the following dynamic assignment for `owner`:

```motoko
shared ({ caller = _initializer_ }) actor class SneedUpgrade() = this{

  func sneed_converter_account() : Account{
    {
      owner = Principal.fromActor(this);
      subaccount = null;
    };
  };

  ...
}
```

This change reflects the canister's accurate identification, eliminates the possibility of operational mishaps resulting from misconfiguration, and ensures that transactions are correctly attributed to the canister in question. Additionally, thorough testing should be conducted to guarantee that the canister ID is dynamically and accurately set across various deployment environments.

### Title: Missing Integration Tests for Sneed Converter dApp
Finding ID: RVVR-SNEED-20

Severity: High

Difficulty: Medium

Type: Testing

Target: N/A

#### Description:

The Sneed Converter dApp currently does not have integration tests included in the repository. Integration tests are crucial for ensuring the application behaves correctly under various scenarios that mirror real-world usage. These tests are important for catching bugs and corner cases, particularly time-based bugs and odd behavior which unit tests may miss. Integration testing is also essential for validating the system's overall reliability, performance, security, and compliance with specified requirements. Without such tests, it is difficult to have confidence that the contract will behave correctly in production.

#### Exploit Scenario

An attacker may take advantage of unknown bugs or edge cases that were not caught due to the absence of integration tests. For example, if there are untested time-based or inter-dependent bugs, an attacker could exploit these to gain an unintended advantage, such as bypassing cooldown periods or triggering unexpected state changes in the dApp.

#### Recommendations

Write a comprehensive suite of integration tests that simulate possible real-world scenarios, including attack vectors. You may utilize testing frameworks and environments that support Motoko and the Internet Computer, such as `dfx` test environments or custom testing setups.

Ensure that each integration test covers a range of scenarios, including:

1. **Activation**: Test the canister's behavior when activated, ensuring it transitions states correctly and enables functionality as expected.
2. **Conversion**: Simulate token transfers and conversions, ensuring that the dApp correctly handles token balances throughout the conversion process.
3. **Cooldown**: Test the cooldown mechanism to ensure it accurately enforces wait times between repeated conversions or refunds.
4. **Refund**: Verify that the OLD token refund functionality works as intended.
5. **Burn**: Make sure the dApp's burn function correctly reduces the total supply of OLD tokens and the dApp's holding of these tokens.
6. **Fee Management**: Test fee deductions and ensure fees are correctly allocated to the specified fee recipient accounts.
7. **Security**: Ensure that only authorized users can perform secured admin actions.
8. **State Persistence**: Verify that the dApp maintains its state after an upgrade.
9. **Transaction Reversion**: Test that the contract correctly reverts its state when a transaction fails after modifying global state.
10. **High Traffic**: Test the dApp under high load to evaluate performance under stress.
11. **Invalid Input**: Ensure that the dApp handles invalid input gracefully and consistently responds with appropriate error messages.

Refer to [ORIGYN-SA/origyn_nft](https://github.com/ORIGYN-SA/origyn_nft/tree/main/src/tests) for examples of integration tests in a different context, which can be adapted and extended to fit the needs of the Sneed Converter dApp.

By implementing integration tests covering these scenarios, the robustness and reliability of your dApp will significantly increase, and you'll be better protected against both known and unknown threats.

### Title: Inadequate Unit Testing for Conversion and Indexing Logic
Finding ID: RVVR-SNEED-21

Severity: High

Difficulty: Medium

Type: Testing

Target: Entire smart contract

#### Description:
During the audit of the smart contract, we have identified a significant lack of unit testing coverage for critical functions within the smart contract, specifically for the `IndexNewBalance` and `IndexOldBalance` functions as well as other functions relevant to the conversion process such as `ConvertOldTokens` and `RefundOldTokens`. The absence of comprehensive unit tests introduces notable risks including the undetection of bugs that could result in incorrect balance calculations, mishandled conversions or refunds, and potential loss of funds for users.

Unit tests are vital to ensure that individual functions within a smart contract behave as expected under various conditions. For the aforementioned functions, it is critical to verify that the calculations of user balances and conversions are accurate, especially when fee deductions, decimals conversion, seeder and burner logic, and token indexing are involved.

#### Exploit Scenario:
Without adequate unit testing, it is plausible that transactions may not be properly indexed - leading to an incorrect balance calculation on the smart contract. For instance, if the `IndexOldBalance` function incorrectly handles refunds or the `IndexNewBalance` function miscalculates the seeding amounts, users' balances could either be inflated or deflated. This would result in erroneous conversion rates when calling the `ConvertOldTokens` function, potentially allowing users to receive more NEW SNEED tokens than they are due, or possibly denying them their fair share.

Moreover, a malicious user could study the contract for weaknesses in the conversion and refund logic that are undetected due to inadequate testing and exploit them to either inflate their balance or incapacitate the smart contract by creating conditions that always fail the balance index checks.

#### Recommendations:
It is strongly recommended to develop a comprehensive suite of unit tests that cover various scenarios including, but not limited to:
- Sending and receiving different amounts of OLD and NEW tokens both from the user's perspective and the contract's perspective.
- Handling of decimal conversions between OLD (`_d12`) and NEW (`_d8`) tokens consistently and accurately.
- Ensuring that fees are correctly applied to transactions and that the balance adjustments are accurate post-fee applications.
- Testing the logic that governs seeders and burners, ensuring that their constraints are correctly enforced.
- Verifying the correctness of cooldown logic to prevent reentrancy and ensuring that balances cannot be manipulated during cooldown periods.
- Thoroughly testing the indexing logic to confirm that it correctly identifies and sums transactions related to the user's address, including edge cases where transaction history might include complex combinations of multiple send and receive events, refunds, and burns.

### Title: Inefficient Map Data Structure in Base Library
Finding ID: RVVR-SNEED-22

Severity: Low

Difficulty: Low

Type: Memory Safety

Target: Line 151, Line 157

#### Description:

The smart contract for the Sneed "Converter" dApp uses the `HashMap` data structure from the Motoko base library. This data structure is utilized in the contract to keep track of the most recent transaction index for the send operations of the new and old tokens to each account . However, the current implementation of `HashMap` in the Motoko base library is known to be inefficient, with a lower maximum number of entries compared to alternative implementations. This inefficiency can lead to potential performance issues, particularly as the scale of operations increases for the smart contract.

#### Exploit Scenario

Although not an exploit in the traditional sense, the inefficiency of the `Map.HashMap` data structure could lead to suboptimal performance, resulting in slower transaction processing times and potential bottlenecks as the number of users and transactions grow. As this dApp scales, the inefficiency could become more pronounced and affect overall user experience negatively.

#### Recommendations

It is recommended to replace the use of `HashMap` with a more efficient map data structure, such as one from the community-contributed library found at https://github.com/ZhenyaUsenko/motoko-hash-map. By implementing a more efficient hash map library, the dApp can handle a larger number of entries with better performance. This change should be a relatively simple drop-in replacement, given the low difficulty level of this improvement.

Following this change, extensive testing should be performed to ensure that the new data structure integrates seamlessly with the existing codebase and that all functionalities work as expected. Additionally, monitoring performance metrics before and after the implementation could provide tangible evidence of the improvement.
